{"version":3,"file":"transcriptParser.js","sourceRoot":"","sources":["../../Util/transcriptParser.ts"],"names":[],"mappings":"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","sourcesContent":["import fs from 'node:fs';\nimport path from 'node:path';\nimport PDFParser from 'pdf2json';\nimport pdfParse from 'pdf-parse';\nimport type {\n  AdditionalInfo,\n  ParsedTranscript,\n  ProgramInfo,\n  StudentInfo,\n  TranscriptCourse,\n  TranscriptTerm,\n  TransferCredit,\n} from '../types/transcript';\nimport { setTimeout } from 'node:timers';\n\n/**\n * TranscriptParser - A utility class to parse academic transcripts from PDF format\n *\n * This parser extracts student information, course details, grades, and GPA information\n * from transcript PDFs following standard academic transcript formats.\n *\n * @example\n * ```typescript\n * const parser = new TranscriptParser();\n * const transcript = await parser.parseFromFile('/path/to/transcript.pdf');\n * console.log(transcript.studentInfo);\n * console.log(transcript.overallGPA);\n * ```\n */\nexport class TranscriptParser {\n  private static readonly STUDENT_ID_STRING = 'Student ID:';\n  private static readonly ACTIVE_STRING = 'Active in Program';\n  /**\n   * Parse a transcript from a PDF file path\n   */\n  async parseFromFile(filePath: string): Promise<ParsedTranscript> {\n    try {\n      const dataBuffer = fs.readFileSync(filePath);\n      return await this.parseFromBuffer(dataBuffer);\n    } catch (error) {\n      throw new Error(\n        `Failed to read transcript file: ${error instanceof Error ? error.message : 'Unknown error'}`,\n      );\n    }\n  }\n\n  /**\n   * Parse a transcript from a Buffer\n   * Uses BOTH pdf-parse (for term detection) and pdf2json (for structured course data)\n   */\n  async parseFromBuffer(buffer: Buffer): Promise<ParsedTranscript> {\n    try {\n      // Step 1: Use pdf-parse to get clean text with correct reading order\n      const pdfParseData = await pdfParse(buffer);\n      const cleanText = pdfParseData.text;\n\n      // Step 2: Use pdf2json to get structured data with columns\n      const pdf2jsonData = await new Promise<any>((resolve, reject) => {\n        const pdfParser = new (PDFParser as any)(null, 1);\n\n        pdfParser.on('pdfParser_dataError', (errData: any) => {\n          reject(new Error(`PDF parsing error: ${errData.parserError}`));\n        });\n\n        pdfParser.on('pdfParser_dataReady', (pdfData: any) => {\n          resolve(pdfData);\n        });\n\n        // pdf2json expects a file path, so we need to write temp file\n        const tempPath = path.join('/tmp', `transcript_${Date.now()}.pdf`);\n        fs.writeFileSync(tempPath, buffer);\n\n        pdfParser.loadPDF(tempPath);\n\n        // Clean up temp file after a delay\n        setTimeout(() => {\n          try {\n            fs.unlinkSync(tempPath);\n          } catch (e) {\n            console.error(e);\n            // Ignore cleanup errors\n          }\n        }, 5000);\n      });\n\n      // Step 3: Parse using both sources\n      return this.parseTranscriptDataHybrid(cleanText, pdf2jsonData);\n    } catch (error) {\n      throw new Error(\n        `Failed to parse transcript: ${error instanceof Error ? error.message : 'Unknown error'}`,\n      );\n    }\n  }\n\n  /**\n   * Hybrid parsing method using both pdf-parse and pdf2json\n   */\n  private parseTranscriptDataHybrid(\n    cleanText: string,\n    pdf2jsonData: any,\n  ): ParsedTranscript {\n    // Use pdf2json to get structured course data\n    const structuredLines = this.extractStructuredLines(pdf2jsonData);\n\n    // Try pdf-parse first for term boundaries\n    const pdfParseLines = cleanText.split('\\n');\n    let termBoundaries = this.findTermBoundariesFromText(pdfParseLines);\n\n    // If pdf-parse didn't find many terms, try extracting from structured lines\n    // (This happens when PDF has all text at same Y coordinate)\n    if (termBoundaries.length < 5) {\n      const structuredTermBoundaries =\n        this.findTermBoundariesFromText(structuredLines);\n      if (structuredTermBoundaries.length > termBoundaries.length) {\n        termBoundaries = structuredTermBoundaries;\n      }\n    }\n\n    // Build student info and metadata from structured lines\n    const studentInfo = this.extractStudentInfo(structuredLines);\n    const programHistory = this.extractProgramHistory(structuredLines);\n    const additionalInfo = this.extractAcademicSummary(structuredLines);\n    const transferCredits = this.extractTransferCredits(structuredLines);\n\n    // Extract courses using term boundaries and structure from pdf2json\n    const terms = this.extractTermsHybrid(termBoundaries, pdf2jsonData);\n\n    return {\n      studentInfo,\n      programHistory,\n      transferCredits,\n      terms,\n      additionalInfo,\n    };\n  }\n\n  /**\n   * Find term boundaries from pdf-parse text (correct reading order)\n   * NOTE: This only extracts actual course terms, not the admit term from program history\n   */\n  private findTermBoundariesFromText(\n    lines: string[],\n  ): Array<{ term: string; year: string; lineIndex: number; gpa?: number }> {\n    const termBoundaries: Array<{\n      term: string;\n      year: string;\n      lineIndex: number;\n      gpa?: number;\n    }> = [];\n    let inCourseSection = false;\n\n    for (let i = 0; i < lines.length; i++) {\n      const line = lines[i].trim();\n\n      // Course section starts after \"Beginning of Undergraduate Record\"\n      // This ensures we skip the program history section (which contains admit term)\n      if (line.includes('Beginning of Undergraduate Record')) {\n        inCourseSection = true;\n        continue;\n      }\n\n      if (line.includes('End of Student Record')) {\n        break;\n      }\n\n      if (!inCourseSection) continue;\n\n      // Match term headers (only actual course terms, not admit term)\n      const termRegex =\n        /^(Winter|Summer|Fall|Spring|Fall\\/Winter|Winter\\/Summer)\\s+(\\d{4}(?:-\\d{2})?)$/;\n      const termMatch = termRegex.exec(line);\n      if (termMatch) {\n        termBoundaries.push({\n          term: termMatch[1],\n          year: termMatch[2],\n          lineIndex: i,\n        });\n      }\n\n      // Match Term GPA and associate with last term\n      if (line.startsWith('Term GPA') && termBoundaries.length > 0) {\n        const gpaRegex = /Term GPA\\s+(\\d+\\.?\\d*)/;\n        const gpaMatch = gpaRegex.exec(line);\n        if (gpaMatch) {\n          termBoundaries.at(-1)!.gpa = Number.parseFloat(gpaMatch[1]);\n        }\n      }\n    }\n\n    return termBoundaries;\n  }\n\n  /**\n   * Extract structured lines from pdf2json (with column separation)\n   * CRITICAL: Use ORIGINAL pdf2json order, NOT Y-sorted!\n   * ALSO: Respect page boundaries - don't join text across pages\n   */\n  private extractStructuredLines(pdfData: any): string[] {\n    // Extract text from all pages in ORIGINAL ORDER\n    const allTextItems: Array<{\n      page: number;\n      order: number;\n      y: number;\n      text: string;\n    }> = [];\n    const pages = pdfData.Pages || [];\n\n    for (const [pageIndex, page] of pages.entries()) {\n      if (page.Texts) {\n        for (const [itemIndex, textItem] of page.Texts.entries()) {\n          const y = textItem.y;\n          const text = decodeURIComponent(textItem.R?.[0]?.T || '');\n          allTextItems.push({ page: pageIndex, order: itemIndex, y, text });\n        }\n      }\n    }\n\n    // Sort by page first, then by ORIGINAL ORDER (NOT Y coordinate)\n    // This preserves pdf2json's reading order which is correct\n    allTextItems.sort((a, b) => {\n      if (a.page !== b.page) {\n        return a.page - b.page;\n      }\n      return a.order - b.order;\n    });\n\n    // Build lines by grouping consecutive text items with similar Y\n    // IMPORTANT: Also break on page boundaries\n    const lines: string[] = [];\n    let currentLine: string[] = [];\n    let lastY = -999;\n    let lastPage = -1;\n    const Y_THRESHOLD = 0.5;\n\n    for (const item of allTextItems) {\n      // Break line on page change OR significant Y change\n      const shouldBreakLine =\n        (Math.abs(item.y - lastY) > Y_THRESHOLD || item.page !== lastPage) &&\n        currentLine.length > 0;\n\n      if (shouldBreakLine) {\n        lines.push(currentLine.join(' | '));\n        currentLine = [];\n      }\n\n      if (item.text.trim().length > 0) {\n        currentLine.push(item.text);\n        lastY = item.y;\n        lastPage = item.page;\n      }\n    }\n\n    if (currentLine.length > 0) {\n      lines.push(currentLine.join(' | '));\n    }\n\n    return lines;\n  }\n  /**\n   * Extract student information\n   */\n  private extractStudentInfo(lines: string[]): StudentInfo {\n    const studentInfo: StudentInfo = {};\n    const expandedLines = this.expandPipeSeparatedLines(lines.slice(0, 50));\n\n    for (let i = 0; i < expandedLines.length; i++) {\n      const line = expandedLines[i];\n      if (!line || line.length < 2) continue;\n\n      this.trySetStudentName(studentInfo, expandedLines, i);\n      this.trySetStudentId(studentInfo, line);\n      this.trySetAddress(studentInfo, expandedLines, i);\n      this.trySetCityProvince(studentInfo, line);\n      this.trySetCountryPostal(studentInfo, line);\n      this.trySetBirthdate(studentInfo, line);\n      this.trySetPermanentCode(studentInfo, line);\n      this.trySetTelephone(studentInfo, line);\n    }\n\n    return studentInfo;\n  }\n\n  private expandPipeSeparatedLines(lines: string[]): string[] {\n    return lines.flatMap((line) =>\n      line.includes(' | ') ? line.split(' | ').map((l) => l.trim()) : [line],\n    );\n  }\n\n  private trySetStudentName(info: StudentInfo, lines: string[], i: number) {\n    const line = lines[i];\n    if (\n      i < lines.length - 1 &&\n      lines[i + 1].startsWith(TranscriptParser.STUDENT_ID_STRING) &&\n      !line.includes('http') &&\n      !line.includes('Page') &&\n      !line.includes('Student Record') &&\n      line.length > 5 &&\n      line.length < 100\n    ) {\n      info.studentName = line;\n    }\n  }\n\n  private trySetStudentId(info: StudentInfo, line: string) {\n    if (line.startsWith(TranscriptParser.STUDENT_ID_STRING)) {\n      const idMatch = /Student ID:\\s*(\\d+)/.exec(line);\n      if (idMatch) info.studentId = idMatch[1];\n    }\n  }\n\n  private trySetAddress(info: StudentInfo, lines: string[], i: number) {\n    const line = lines[i];\n    if (\n      i > 0 &&\n      lines[i - 1].startsWith(TranscriptParser.STUDENT_ID_STRING) &&\n      !line.includes(',') &&\n      !line.includes('Canada') &&\n      !line.startsWith('Birthdate') &&\n      !line.startsWith('Student')\n    ) {\n      info.address = line;\n    }\n  }\n\n  private trySetCityProvince(info: StudentInfo, line: string) {\n    if (\n      (line.includes(', QC') ||\n        line.includes(', ON') ||\n        line.includes(', BC')) &&\n      !line.includes('Canada') &&\n      !line.includes('|') &&\n      line.length < 100\n    ) {\n      const parts = line.split(',').map((p) => p.trim());\n      if (parts.length >= 2) {\n        info.city = parts[0];\n        info.province = parts[1];\n      }\n    }\n  }\n\n  private trySetCountryPostal(info: StudentInfo, line: string) {\n    if (line.startsWith('Canada')) {\n      info.country = 'Canada';\n      const postalRegex = /([A-Z]\\d[A-Z]\\s?\\d[A-Z]\\d)/;\n      const postalMatch = postalRegex.exec(line);\n      if (postalMatch) info.postalCode = postalMatch[1];\n    }\n  }\n\n  private trySetBirthdate(info: StudentInfo, line: string) {\n    if (line.startsWith('Birthdate:')) {\n      const birthdateRegex = /Birthdate:\\s*(.+)/;\n      const match = birthdateRegex.exec(line);\n      if (match) info.birthdate = match[1].trim();\n    }\n  }\n\n  private trySetPermanentCode(info: StudentInfo, line: string) {\n    if (line.startsWith('Permanent Code:')) {\n      const codeRegex = /Permanent Code:\\s*(.+)/;\n      const match = codeRegex.exec(line);\n      if (match) info.permanentCode = match[1].trim();\n    }\n  }\n\n  private trySetTelephone(info: StudentInfo, line: string) {\n    if (line.startsWith('Telephone:')) {\n      const phoneRegex = /Telephone:\\s*(.+)/;\n      const match = phoneRegex.exec(line);\n      if (match) info.telephone = match[1].trim();\n    }\n  }\n\n  /**\n   * Extract program history\n   */\n  private extractProgramHistory(lines: string[]): ProgramInfo[] {\n    const expandedLines = this.expandPipeSeparatedLines(lines);\n    const programs: ProgramInfo[] = [];\n\n    for (let i = 0; i < expandedLines.length; i++) {\n      if (expandedLines[i] === TranscriptParser.ACTIVE_STRING) {\n        const date = i + 1 < expandedLines.length ? expandedLines[i + 1] : '';\n        const details = this.extractProgramDetails(expandedLines, i + 2);\n        programs.push({\n          status: TranscriptParser.ACTIVE_STRING,\n          startDate: date,\n          admitTerm: details.admitTerm,\n          degreeType: details.degreeType,\n          major: details.major,\n          note: details.note,\n        });\n      }\n    }\n    return programs;\n  }\n\n  private extractProgramDetails(\n    lines: string[],\n    startIdx: number,\n  ): {\n    degreeType: string;\n    major: string;\n    note: string;\n    admitTerm: string;\n  } {\n    let degreeType = '';\n    let major = '';\n    let note = '';\n    let admitTerm = '';\n    for (let j = startIdx; j < Math.min(startIdx + 8, lines.length); j++) {\n      const line = lines[j];\n      if (line.includes('Bachelor of') || line.includes('Master of')) {\n        degreeType = line;\n      } else if (\n        line.includes('Engineering') &&\n        !line.includes('Bachelor') &&\n        !degreeType.includes(line)\n      ) {\n        major = line;\n      } else if (line.includes('Admit Term')) {\n        admitTerm = j + 1 < lines.length ? lines[j + 1] : '';\n      } else if (\n        line.includes('Matriculated') ||\n        line.includes('Member Institute') ||\n        line.includes('Concentration Change')\n      ) {\n        note = line;\n      } else if (\n        line === TranscriptParser.ACTIVE_STRING ||\n        line.includes('Min. Credits Required')\n      ) {\n        break;\n      }\n    }\n    return { degreeType, major, note, admitTerm };\n  }\n\n  /**\n   * Extract transfer credits from prior institutions\n   */\n  private extractTransferCredits(lines: string[]): TransferCredit[] {\n    return lines\n      .filter(this.isTransferCreditHeader)\n      .flatMap(this.extractTransferCreditsFromLine);\n  }\n\n  private isTransferCreditHeader(line: string): boolean {\n    return line.includes(' | ') && line.includes('YEAR ATTENDED');\n  }\n\n  private extractTransferCreditsFromLine(line: string): TransferCredit[] {\n    const parts = line.split(' | ').map((p) => p.trim());\n    const transferCredits: TransferCredit[] = [];\n    for (let i = 0; i < parts.length - 5; i++) {\n      const [dept, number, description, grade, year, creditsStr] = parts.slice(\n        i,\n        i + 6,\n      );\n      if (\n        /^[A-Z]{2,4}$/.test(dept) &&\n        /^\\d{3}$/.test(number) &&\n        (grade === 'EX' || grade === 'PASS') &&\n        /^\\d+(?:\\.\\d+)?$/.test(creditsStr)\n      ) {\n        transferCredits.push({\n          courseCode: `${dept} ${number}`,\n          courseTitle: description,\n          grade: grade,\n          yearAttended: year === 'NA' ? undefined : year,\n          programCreditsEarned: Number.parseFloat(creditsStr),\n        });\n      }\n    }\n    return transferCredits;\n  }\n\n  /**\n   * Extract academic summary\n   */\n  private extractAcademicSummary(lines: string[]): AdditionalInfo {\n    const info: AdditionalInfo = {};\n    const expandedLines = this.expandPipeSeparatedLines(lines);\n\n    for (let i = 0; i < expandedLines.length; i++) {\n      this.trySetNumericField(\n        info,\n        expandedLines,\n        i,\n        'Min. Credits Required:',\n        'minCreditsRequired',\n      );\n      this.trySetNumericField(\n        info,\n        expandedLines,\n        i,\n        'Program Credits Earned:',\n        'programCreditsEarned',\n      );\n      this.trySetNumericField(\n        info,\n        expandedLines,\n        i,\n        'Cumulative GPA:',\n        'overallGPA',\n      );\n      this.trySetWritingSkillsRequirement(info, expandedLines[i]);\n    }\n\n    return info;\n  }\n\n  private trySetNumericField(\n    info: AdditionalInfo,\n    lines: string[],\n    i: number,\n    label: string,\n    field: 'overallGPA' | 'minCreditsRequired' | 'programCreditsEarned',\n  ) {\n    if (lines[i] === label && i + 1 < lines.length) {\n      const nextLine = lines[i + 1].trim();\n      const value = Number.parseFloat(nextLine);\n      if (!Number.isNaN(value)) {\n        info[field] = value;\n      }\n    }\n  }\n\n  private trySetWritingSkillsRequirement(info: AdditionalInfo, line: string) {\n    if (line.startsWith('Writing Skills Requirement:')) {\n      const reqRegex = /Writing Skills Requirement:\\s*(.+)/;\n      const reqMatch = reqRegex.exec(line);\n      if (reqMatch) info.writingSkillsRequirement = reqMatch[1].trim();\n    }\n  }\n\n  /**\n   * Extract terms using hybrid approach:\n   * - Term boundaries from pdf-parse (correct order with line indices)\n   * - Course data from pdf2json (structured columns with order preservation)\n   */\n  private extractTermsHybrid(\n    termBoundaries: Array<{\n      term: string;\n      year: string;\n      lineIndex: number;\n      gpa?: number;\n    }>,\n    pdf2jsonData: any,\n  ): TranscriptTerm[] {\n    const allCourses = this.flattenCoursesByPage(\n      this.extractCoursesFromPdf2json(pdf2jsonData),\n    );\n    let courseIndex = 0;\n    const terms: TranscriptTerm[] = [];\n\n    for (const [termIdx, boundary] of termBoundaries.entries()) {\n      const term: TranscriptTerm = {\n        term: boundary.term,\n        year: boundary.year,\n        courses: [],\n        termGPA: boundary.gpa,\n        termCredits: undefined,\n      };\n\n      courseIndex = this.assignCoursesToTerm(\n        allCourses,\n        courseIndex,\n        term,\n        termIdx,\n        termBoundaries.length,\n      );\n\n      terms.push(term);\n    }\n\n    return this.cleanupTerms(terms);\n  }\n\n  private flattenCoursesByPage(\n    coursesByPage: Map<\n      number,\n      Array<{ course: TranscriptCourse; order: number }>\n    >,\n  ): Array<TranscriptCourse & { page: number; order: number }> {\n    const allCourses: Array<\n      TranscriptCourse & { page: number; order: number }\n    > = [];\n    for (const [page, coursesOnPage] of coursesByPage) {\n      for (const courseInfo of coursesOnPage) {\n        allCourses.push({\n          ...courseInfo.course,\n          page,\n          order: courseInfo.order,\n        });\n      }\n    }\n    return allCourses;\n  }\n\n  private assignCoursesToTerm(\n    allCourses: Array<TranscriptCourse & { page: number; order: number }>,\n    startIdx: number,\n    term: TranscriptTerm,\n    termIdx: number,\n    totalTerms: number,\n  ): number {\n    let courseIndex = startIdx;\n    while (courseIndex < allCourses.length) {\n      const currentCourse = allCourses[courseIndex];\n      const { page, order, ...cleanCourse } = currentCourse;\n      cleanCourse.term = term.term;\n      cleanCourse.year = term.year;\n      term.courses.push(cleanCourse);\n\n      courseIndex++;\n      const nextCourse =\n        courseIndex < allCourses.length ? allCourses[courseIndex] : null;\n      if (!nextCourse) break;\n\n      const samePage = currentCourse.page === nextCourse.page;\n      const gap = nextCourse.order - currentCourse.order;\n      const isTermBoundary = (samePage && gap >= 20) || !samePage;\n\n      if (isTermBoundary && termIdx < totalTerms - 1) break;\n    }\n    return courseIndex;\n  }\n\n  /**\n   * Extract courses directly from pdf2json data, preserving page and order information\n   */\n  private extractCoursesFromPdf2json(\n    pdf2jsonData: any,\n  ): Map<number, Array<{ course: TranscriptCourse; order: number }>> {\n    const coursesByPage = new Map<\n      number,\n      Array<{ course: TranscriptCourse; order: number }>\n    >();\n\n    const pages = pdf2jsonData.Pages || [];\n\n    for (const [pageIdx, page] of pages.entries()) {\n      const coursesOnPage: Array<{ course: TranscriptCourse; order: number }> =\n        [];\n      const texts = page.Texts || [];\n\n      // Iterate through texts to find course patterns\n      for (let i = 0; i < texts.length - 2; i++) {\n        const item = texts[i];\n        const next1 = texts[i + 1];\n        const next2 = texts[i + 2];\n\n        const itemText = decodeURIComponent(item.R?.[0]?.T || '').trim();\n        const next1Text = decodeURIComponent(next1.R?.[0]?.T || '').trim();\n        const next2Text = decodeURIComponent(next2.R?.[0]?.T || '').trim();\n\n        // Only look at items with negative Y (course data section)\n        if (\n          item.y < 0 &&\n          /^[A-Z]{2,4}$/.test(itemText) &&\n          itemText.length <= 4 &&\n          ![\n            'COURSE',\n            'GRADE',\n            'GPA',\n            'AVG',\n            'SIZE',\n            'OTHER',\n            'NOTATION',\n            'CLASS',\n            'PROGRAM',\n            'EARNED',\n            'EX',\n            'NA',\n          ].includes(itemText) &&\n          /^\\d{3}$/.test(next1Text) &&\n          /^[A-Z0-9]{1,3}$/.test(next2Text)\n        ) {\n          // Found a course! Now parse its full details\n          const course = this.parseCoursePdf2jsonData(texts, i);\n          if (course) {\n            coursesOnPage.push({ course, order: i });\n          }\n        }\n      }\n\n      if (coursesOnPage.length > 0) {\n        coursesByPage.set(pageIdx, coursesOnPage);\n      }\n    }\n\n    return coursesByPage;\n  }\n\n  /**\n   * Parse a course from pdf2json raw data starting at the given index\n   */\n  private parseCoursePdf2jsonData(\n    texts: any[],\n    startIndex: number,\n  ): TranscriptCourse | null {\n    if (startIndex + 5 >= texts.length) return null;\n\n    const dept = this.decodeText(texts, startIndex);\n    const number = this.decodeText(texts, startIndex + 1);\n    const section = this.decodeText(texts, startIndex + 2).trim();\n    const courseCode = `${dept} ${number}`;\n\n    const { title, nextIndex } = this.collectCourseTitle(texts, startIndex + 3);\n    let titleIndex = nextIndex;\n\n    if (!this.isCreditsField(texts, titleIndex)) return null;\n    const credits = Number.parseFloat(this.decodeText(texts, titleIndex));\n    titleIndex++;\n\n    if (titleIndex >= texts.length) return null;\n    const grade = this.decodeText(texts, titleIndex).toUpperCase();\n    titleIndex++;\n\n    let gpa, classAvg, classSize, other;\n\n    if (!this.isSpecialGrade(grade)) {\n      ({ gpa, classAvg, classSize, titleIndex } = this.parseLetterGradeFields(\n        texts,\n        titleIndex,\n      ));\n    } else if (this.isZeroGrade(grade)) {\n      titleIndex = this.skipToOtherField(texts, titleIndex);\n    } else {\n      ({ titleIndex } = this.parsePassExemptedCredits(texts, titleIndex));\n    }\n\n    other = this.parseOtherField(texts, titleIndex);\n\n    return {\n      courseCode,\n      section,\n      courseTitle: title,\n      credits,\n      grade,\n      notation: undefined,\n      gpa,\n      classAvg,\n      classSize,\n      term: '',\n      year: '',\n      other,\n    };\n  }\n\n  private decodeText(texts: any[], idx: number): string {\n    return decodeURIComponent(texts[idx]?.R?.[0]?.T || '');\n  }\n\n  private collectCourseTitle(\n    texts: any[],\n    idx: number,\n  ): { title: string; nextIndex: number } {\n    let title = '';\n    let count = 0;\n    while (\n      idx < texts.length &&\n      !/^\\d+\\.\\d{2}$/.test(this.decodeText(texts, idx))\n    ) {\n      title += this.decodeText(texts, idx) + ' ';\n      idx++;\n      count++;\n      if (count > 15) break;\n    }\n    return { title: title.trim(), nextIndex: idx };\n  }\n\n  private isCreditsField(texts: any[], idx: number): boolean {\n    return (\n      idx < texts.length && /^\\d+\\.\\d{2}$/.test(this.decodeText(texts, idx))\n    );\n  }\n\n  private isSpecialGrade(grade: string): boolean {\n    return ['PASS', 'EX', '0.00', '0', '0.0'].includes(grade);\n  }\n\n  private isZeroGrade(grade: string): boolean {\n    return ['0.00', '0', '0.0'].includes(grade);\n  }\n\n  private parseLetterGradeFields(\n    texts: any[],\n    idx: number,\n  ): {\n    gpa?: number;\n    classAvg?: number;\n    classSize?: number;\n    programCredits?: number;\n    titleIndex: number;\n  } {\n    let gpa, classAvg, classSize, programCredits;\n    if (this.isCreditsField(texts, idx)) {\n      gpa = Number.parseFloat(this.decodeText(texts, idx));\n      idx++;\n    }\n    if (this.isCreditsField(texts, idx)) {\n      classAvg = Number.parseFloat(this.decodeText(texts, idx));\n      idx++;\n    }\n    if (idx < texts.length && /^\\d{1,4}$/.test(this.decodeText(texts, idx))) {\n      classSize = Number.parseInt(this.decodeText(texts, idx));\n      idx++;\n    }\n    if (this.isCreditsField(texts, idx)) {\n      programCredits = Number.parseFloat(this.decodeText(texts, idx));\n      idx++;\n    }\n    return { gpa, classAvg, classSize, programCredits, titleIndex: idx };\n  }\n\n  private skipToOtherField(texts: any[], idx: number): number {\n    while (\n      idx < texts.length &&\n      !['WKRT', 'RPT', 'EX'].includes(this.decodeText(texts, idx))\n    ) {\n      idx++;\n    }\n    return idx;\n  }\n\n  private parsePassExemptedCredits(\n    texts: any[],\n    idx: number,\n  ): { programCredits?: number; titleIndex: number } {\n    while (\n      idx < texts.length &&\n      !/^\\d+\\.\\d{2}$/.test(this.decodeText(texts, idx))\n    ) {\n      idx++;\n    }\n    let programCredits;\n    if (idx < texts.length) {\n      programCredits = Number.parseFloat(this.decodeText(texts, idx));\n      idx++;\n    }\n    return { programCredits, titleIndex: idx };\n  }\n\n  private parseOtherField(texts: any[], idx: number): string | undefined {\n    if (\n      idx < texts.length &&\n      ['WKRT', 'RPT', 'EX'].includes(this.decodeText(texts, idx))\n    ) {\n      return this.decodeText(texts, idx);\n    }\n    return undefined;\n  }\n\n  /**\n   * Clean up terms - remove empty terms and fix term assignments\n   */\n  private cleanupTerms(terms: TranscriptTerm[]): TranscriptTerm[] {\n    // Remove empty terms\n    const nonEmptyTerms = terms.filter((term) => term.courses.length > 0);\n\n    // Sort terms by year and term order\n    // Fall/Winter spans two semesters, so it comes after Fall but represents the transition to Winter\n    const termOrder = {\n      Winter: 1,\n      Spring: 2,\n      Summer: 3,\n      Fall: 4,\n      'Fall/Winter': 4.5,\n    };\n    nonEmptyTerms.sort((a, b) => {\n      const yearDiff = Number.parseInt(a.year) - Number.parseInt(b.year);\n      if (yearDiff !== 0) return yearDiff;\n      return (\n        (termOrder[a.term as keyof typeof termOrder] || 0) -\n        (termOrder[b.term as keyof typeof termOrder] || 0)\n      );\n    });\n\n    return nonEmptyTerms;\n  }\n}\n\nexport default TranscriptParser;\n"]}