{"version":3,"file":"Session_Util.js","sourceRoot":"","sources":["../../Util/Session_Util.ts"],"names":[],"mappings":"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","sourcesContent":["import crypto from 'node:crypto';\n\nconst session_algo = process.env.SESSION_ALGO as crypto.CipherGCMTypes;\n\nexport type SessionToken = {\n  key: string;\n  iv: string;\n  salt: number;\n};\n\nexport type UserHeaders = {\n  agent: string;\n  ip_addr: string;\n};\n\nfunction getEncryptionKey() {\n  const secret = process.env.JWT_SECRET || 'default-secret';\n  return crypto.createHash('sha256').update(secret).digest();\n}\n\n/**\n ** The function responsible for decrypting the session information in the token\n * @param token The session token\n * @returns\n * - A string containing the decrypted information\n */\nfunction decryptToken(token: SessionToken): string {\n  const { key, iv } = token;\n  const session_key = getEncryptionKey();\n\n  const message = Buffer.from(key, 'base64');\n  const tag = message.subarray(-16);\n\n  const encrypted = message.subarray(0, -16);\n\n  const decipher = crypto.createDecipheriv(\n    session_algo,\n    session_key,\n    Buffer.from(iv, 'base64'),\n  );\n  decipher.setAuthTag(tag);\n\n  const decrypted = Buffer.concat([\n    decipher.update(encrypted),\n    decipher.final(),\n  ]).toString();\n\n  return decrypted;\n}\n\n/**\n ** This function is responsible for the verification of session tokens,\n ** based on the information encrypted in the token and the user's request headers\n * @param session The headers contained in the session token\n * @param user The user's request headers (User-agent and IP address)\n * @returns\n * - TRUE: If the token is valid\n * - FALSE: If the token is invalid\n */\nexport function verifySession(token: SessionToken, user: UserHeaders): boolean {\n  // SECURITY: Verify session by comparing user-agent and IP address\n  // This prevents token theft and ensures session is tied to specific device/network\n  const [agent, ip_addr] = decryptToken(token).split('|');\n  return agent === user.agent && ip_addr === user.ip_addr;\n}\n\n/**\n ** This function is responsible for the creation of session tokens\n * @param user The user's request headers (User-agent and IP address)\n * @param salt Optional. The salt is available if the user already has a token\n * @returns\n * - The Session token\n */\nexport function createSessionToken(\n  user: UserHeaders,\n  salt?: number,\n): SessionToken {\n  //? Gather encryption info\n  const new_salt = salt ? salt + 1 : 1;\n  const { agent, ip_addr } = user;\n  const session_key = getEncryptionKey();\n\n  //? Encryption\n  const iv = crypto.randomBytes(12);\n  const cipher = crypto.createCipheriv(session_algo, session_key, iv);\n  const encrypted = Buffer.concat([\n    cipher.update(`${agent}|${ip_addr}|${new_salt}`),\n    cipher.final(),\n  ]);\n  const tag = cipher.getAuthTag();\n\n  //? Build Session token\n  const token: SessionToken = {\n    key: Buffer.concat([encrypted, tag]).toString('base64'),\n    iv: iv.toString('base64'),\n    salt: new_salt,\n  };\n\n  return token;\n}\n\n/**\n ** Function handles the refresh logic and provides a new session token\n * @param token The user's session token\n * @param user The user's request headers (User-agent and IP address)\n * @returns\n * - A new session token, if the provided token is valid\n * - Or NULL\n */\nexport function refreshSession(\n  token: SessionToken,\n  user: UserHeaders,\n): SessionToken | null {\n  if (!verifySession(token, user)) return null;\n\n  const salt = decryptToken(token).split('|')[2];\n  const new_token: SessionToken = createSessionToken(\n    user,\n    Number.parseInt(salt),\n  );\n\n  return new_token;\n}\n"]}