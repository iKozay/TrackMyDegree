/**
 * Auth Routes (MongoDB)
 *
 * Handles authentication operations using MongoDB
 */

import HTTP from '@Util/HTTPCodes';
import express, { Request, Response } from 'express';
import { authController, UserType } from '@controllers/mondoDBControllers';
import { jwtService } from '../../services/jwtService';
import { UserHeaders } from '@Util/Session_Util';

const router = express.Router();

const INTERNAL_SERVER_ERROR = 'Internal server error';
const EMPTY_REQUEST_BODY = 'Request body cannot be empty';

function extractUserHeaders(req: Request): UserHeaders {
  return {
    agent: req.headers['user-agent'] || '',
    ip_addr: req.ip || '',
  };
}

/**
 * POST /auth/login - User login
 */
router.post('/login', async (req: Request, res: Response) => {
  try {
    const { email, password } = req.body;

    if (!email || !password) {
      res.status(HTTP.BAD_REQUEST).json({
        error: 'Email and password are required',
      });
      return;
    }

    const user = await authController.authenticate(email, password);

    if (!user) {
      res.status(HTTP.UNAUTHORIZED).json({
        error: 'Incorrect email or password',
      });
      return;
    }

    const userHeaders = extractUserHeaders(req);
    const accessToken = jwtService.generateToken(
      {
        orgId: process.env.JWT_ORG_ID!,
        userId: user._id,
        type: user.type,
      },
      userHeaders,
    );
    const refreshToken = jwtService.generateToken(
      {
        orgId: process.env.JWT_ORG_ID!,
        userId: user._id,
        type: user.type,
      },
      userHeaders,
      undefined,
      true,
    );

    const accessCookie = jwtService.setAccessCookie(accessToken);
    const refreshCookie = jwtService.setRefreshCookie(refreshToken);

    res.cookie(accessCookie.name, accessCookie.value, accessCookie.config);
    res.cookie(refreshCookie.name, refreshCookie.value, refreshCookie.config);

    res.status(HTTP.OK).json({
      message: 'Login successful',
      user: {
        _id: user._id,
        email: user.email,
        fullname: user.fullname,
        type: user.type,
      },
    });
  } catch (error) {
    console.error('Error in POST /auth/login', error);
    res.status(HTTP.SERVER_ERR).json({ error: INTERNAL_SERVER_ERROR });
  }
});

/**
 * POST /auth/signup - User registration
 */
router.post('/signup', async (req: Request, res: Response) => {
  try {
    if (!req.body || Object.keys(req.body).length === 0) {
      res.status(HTTP.BAD_REQUEST).json({
        error: EMPTY_REQUEST_BODY,
      });
      return;
    }

    const { email, hashed_password, fullname, type } = req.body;

    if (!email || !hashed_password || !fullname || !type) {
      res.status(HTTP.BAD_REQUEST).json({
        error: 'Email, password, fullname, and type are required',
      });
      return;
    }

    // Validate user type
    if (!Object.values(UserType).includes(type)) {
      res.status(HTTP.BAD_REQUEST).json({
        error: 'Invalid user type',
      });
      return;
    }

    const userInfo = {
      email,
      password: hashed_password, // Frontend sends hashed_password, map to password
      fullname,
      type: type as UserType,
      _id: '', // Will be generated by controller
    };

    const result = await authController.registerUser(userInfo);

    if (result) {
      res.status(HTTP.CREATED).json({
        message: 'User registered successfully',
        _id: result._id,
      });
    } else {
      res.status(HTTP.CONFLICT).json({
        error: 'User with this email already exists',
      });
    }
  } catch (error) {
    console.error('Error in POST /auth/signup', error);
    res.status(HTTP.SERVER_ERR).json({ error: INTERNAL_SERVER_ERROR });
  }
});

/**
 * POST /auth/forgot-password - Initiate password reset
 */
router.post('/forgot-password', async (req: Request, res: Response) => {
  try {
    if (!req.body || !req.body.email) {
      res.status(HTTP.BAD_REQUEST).json({
        error: EMPTY_REQUEST_BODY,
      });
      return;
    }

    const { email } = req.body;
    const result = await authController.forgotPassword(email);

    res.status(HTTP.ACCEPTED).json(result);
  } catch (error) {
    console.error('Error in POST /auth/forgot-password', error);
    res.status(HTTP.SERVER_ERR).json({ error: INTERNAL_SERVER_ERROR });
  }
});

/**
 * POST /auth/reset-password - Reset password with OTP
 */
router.post('/reset-password', async (req: Request, res: Response) => {
  try {
    if (!req.body) {
      res.status(HTTP.BAD_REQUEST).json({
        error: EMPTY_REQUEST_BODY,
      });
      return;
    }

    const { email, otp, newPassword } = req.body;

    if (!email || !otp || !newPassword) {
      res.status(HTTP.BAD_REQUEST).json({
        error: 'Email, OTP, and newPassword are required',
      });
      return;
    }

    const result = await authController.resetPassword(email, otp, newPassword);

    if (result) {
      res.status(HTTP.ACCEPTED).json({
        message: 'Password reset successfully',
      });
    } else {
      res.status(HTTP.UNAUTHORIZED).json({
        error: 'Invalid or expired OTP',
      });
    }
  } catch (error) {
    console.error('Error in POST /auth/reset-password', error);
    res.status(HTTP.SERVER_ERR).json({ error: INTERNAL_SERVER_ERROR });
  }
});

export default router;

